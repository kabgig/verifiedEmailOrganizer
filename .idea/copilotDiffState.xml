<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Main2.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Main2.java" />
              <option name="originalContent" value="package org.example;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVPrinter;&#10;import org.apache.commons.csv.CSVRecord;&#10;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.io.Writer;&#10;import java.nio.file.DirectoryStream;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Main2 {&#10;&#10;    public static void main2(String[] args) {&#10;        // Get the user's desktop path&#10;        String desktopPath = System.getProperty(&quot;user.home&quot;) + &quot;/Desktop&quot;;&#10;        String prospectsFolder = desktopPath + &quot;/prospects&quot;;&#10;        String outputFile = desktopPath + &quot;/combined_prospects.csv&quot;;&#10;&#10;        try {&#10;            combineProspectsCsvFiles(prospectsFolder, outputFile);&#10;            System.out.println(&quot;Successfully combined all prospect CSV files into: &quot; + outputFile);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error processing prospect files: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static void combineProspectsCsvFiles(String prospectsFolder, String outputFile) throws IOException {&#10;        Path prospectsPath = Paths.get(prospectsFolder);&#10;&#10;        if (!Files.exists(prospectsPath) || !Files.isDirectory(prospectsPath)) {&#10;            throw new IOException(&quot;Prospects folder does not exist: &quot; + prospectsFolder);&#10;        }&#10;&#10;        List&lt;String&gt; headers = null;&#10;        boolean isFirstFile = true;&#10;        int totalRecords = 0;&#10;        int processedFiles = 0;&#10;        int skippedRecords = 0;&#10;&#10;        try (Writer writer = Files.newBufferedWriter(Paths.get(outputFile))) {&#10;            CSVPrinter csvPrinter = null;&#10;&#10;            // Read all CSV files from the prospects folder&#10;            try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(prospectsPath, &quot;*.csv&quot;)) {&#10;                for (Path csvFile : stream) {&#10;                    System.out.println(&quot;Processing file: &quot; + csvFile.getFileName());&#10;&#10;                    try (Reader reader = Files.newBufferedReader(csvFile);&#10;                         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                                 .withFirstRecordAsHeader()&#10;                                 .withIgnoreEmptyLines(true)&#10;                                 .withTrim(true)&#10;                                 .withAllowMissingColumnNames(true))) {&#10;&#10;                        if (isFirstFile) {&#10;                            // Get headers from the first file and create CSV printer&#10;                            headers = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            csvPrinter = new CSVPrinter(writer,&#10;                                CSVFormat.DEFAULT.withHeader(headers.toArray(new String[0])));&#10;                            isFirstFile = false;&#10;                            System.out.println(&quot;Headers found: &quot; + String.join(&quot;, &quot;, headers));&#10;                        } else {&#10;                            // Validate that current file has the same headers&#10;                            List&lt;String&gt; currentHeaders = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            if (!headers.equals(currentHeaders)) {&#10;                                System.out.println(&quot;Warning: File &quot; + csvFile.getFileName() +&#10;                                    &quot; has different headers. Expected: &quot; + headers +&#10;                                    &quot;, Found: &quot; + currentHeaders);&#10;                                // Continue processing but log the warning&#10;                            }&#10;                        }&#10;&#10;                        // Find email and personal_email column indices&#10;                        int emailIndex = -1;&#10;                        int personalEmailIndex = -1;&#10;                        for (int i = 0; i &lt; headers.size(); i++) {&#10;                            String header = headers.get(i);&#10;                            if (header.equalsIgnoreCase(&quot;email&quot;)) {&#10;                                emailIndex = i;&#10;                            } else if (header.equalsIgnoreCase(&quot;personal_email&quot;)) {&#10;                                personalEmailIndex = i;&#10;                            }&#10;                        }&#10;&#10;                        // Copy records from current file with email processing&#10;                        int fileRecords = 0;&#10;                        int fileSkipped = 0;&#10;                        for (CSVRecord record : csvParser) {&#10;                            List&lt;String&gt; recordValues = new ArrayList&lt;&gt;();&#10;&#10;                            // Check email and personal_email values&#10;                            String emailValue = &quot;&quot;;&#10;                            String personalEmailValue = &quot;&quot;;&#10;&#10;                            try {&#10;                                emailValue = record.get(&quot;email&quot;);&#10;                                if (emailValue == null) emailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                emailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            try {&#10;                                personalEmailValue = record.get(&quot;personal_email&quot;);&#10;                                if (personalEmailValue == null) personalEmailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                personalEmailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            // Skip if both email and personal_email are empty&#10;                            if (emailValue.trim().isEmpty() &amp;&amp; personalEmailValue.trim().isEmpty()) {&#10;                                fileSkipped++;&#10;                                skippedRecords++;&#10;                                continue;&#10;                            }&#10;&#10;                            // Use personal_email if email is empty but personal_email is not&#10;                            String finalEmailValue = emailValue.trim().isEmpty() ? personalEmailValue : emailValue;&#10;&#10;                            // Extract values for each header column&#10;                            for (int i = 0; i &lt; headers.size(); i++) {&#10;                                String header = headers.get(i);&#10;                                String value = &quot;&quot;;&#10;&#10;                                if (header.equalsIgnoreCase(&quot;email&quot;)) {&#10;                                    // Use the processed email value&#10;                                    value = finalEmailValue;&#10;                                } else {&#10;                                    try {&#10;                                        value = record.get(header);&#10;                                        if (value == null) {&#10;                                            value = &quot;&quot;;&#10;                                        }&#10;                                    } catch (IllegalArgumentException e) {&#10;                                        // Column doesn't exist in this file, use empty string&#10;                                        value = &quot;&quot;;&#10;                                    }&#10;                                }&#10;                                recordValues.add(value);&#10;                            }&#10;&#10;                            csvPrinter.printRecord(recordValues);&#10;                            fileRecords++;&#10;                            totalRecords++;&#10;                        }&#10;&#10;                        System.out.println(&quot;  - Records from &quot; + csvFile.getFileName() + &quot;: &quot; + fileRecords);&#10;                        if (fileSkipped &gt; 0) {&#10;                            System.out.println(&quot;  - Skipped records (no email): &quot; + fileSkipped);&#10;                        }&#10;                        processedFiles++;&#10;&#10;                    } catch (IOException e) {&#10;                        System.err.println(&quot;Error reading file &quot; + csvFile.getFileName() + &quot;: &quot; + e.getMessage());&#10;                        // Continue with other files&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (csvPrinter != null) {&#10;                csvPrinter.flush();&#10;            }&#10;&#10;            System.out.println(&quot;\n=== Summary ===&quot;);&#10;            System.out.println(&quot;Files processed: &quot; + processedFiles);&#10;            System.out.println(&quot;Total records combined: &quot; + totalRecords);&#10;            System.out.println(&quot;Total records skipped (no email): &quot; + skippedRecords);&#10;            System.out.println(&quot;Output file: &quot; + outputFile);&#10;&#10;            if (processedFiles == 0) {&#10;                System.out.println(&quot;No CSV files found in the prospects folder!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Alternative main method if you want to run this class directly&#10;    public static void main(String[] args) {&#10;        main2(args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVPrinter;&#10;import org.apache.commons.csv.CSVRecord;&#10;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.io.Writer;&#10;import java.nio.file.DirectoryStream;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;&#10;public class Main2 {&#10;&#10;    public static void main2(String[] args) {&#10;        // Get the user's desktop path&#10;        String desktopPath = System.getProperty(&quot;user.home&quot;) + &quot;/Desktop&quot;;&#10;        String prospectsFolder = desktopPath + &quot;/prospects&quot;;&#10;        String outputFile = desktopPath + &quot;/combined_prospects.csv&quot;;&#10;&#10;        try {&#10;            combineProspectsCsvFiles(prospectsFolder, outputFile);&#10;            System.out.println(&quot;Successfully combined all prospect CSV files into: &quot; + outputFile);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error processing prospect files: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static void combineProspectsCsvFiles(String prospectsFolder, String outputFile) throws IOException {&#10;        Path prospectsPath = Paths.get(prospectsFolder);&#10;&#10;        if (!Files.exists(prospectsPath) || !Files.isDirectory(prospectsPath)) {&#10;            throw new IOException(&quot;Prospects folder does not exist: &quot; + prospectsFolder);&#10;        }&#10;&#10;        List&lt;String&gt; headers = null;&#10;        boolean isFirstFile = true;&#10;        int totalRecords = 0;&#10;        int processedFiles = 0;&#10;        int skippedRecords = 0;&#10;        int duplicateRecords = 0;&#10;&#10;        // Track unique emails to avoid duplicates&#10;        Set&lt;String&gt; uniqueEmails = new HashSet&lt;&gt;();&#10;&#10;        try (Writer writer = Files.newBufferedWriter(Paths.get(outputFile))) {&#10;            CSVPrinter csvPrinter = null;&#10;&#10;            // Read all CSV files from the prospects folder&#10;            try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(prospectsPath, &quot;*.csv&quot;)) {&#10;                for (Path csvFile : stream) {&#10;                    System.out.println(&quot;Processing file: &quot; + csvFile.getFileName());&#10;&#10;                    try (Reader reader = Files.newBufferedReader(csvFile);&#10;                         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                                 .withFirstRecordAsHeader()&#10;                                 .withIgnoreEmptyLines(true)&#10;                                 .withTrim(true)&#10;                                 .withAllowMissingColumnNames(true))) {&#10;&#10;                        if (isFirstFile) {&#10;                            // Get headers from the first file and create CSV printer&#10;                            headers = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            csvPrinter = new CSVPrinter(writer,&#10;                                CSVFormat.DEFAULT.withHeader(headers.toArray(new String[0])));&#10;                            isFirstFile = false;&#10;                            System.out.println(&quot;Headers found: &quot; + String.join(&quot;, &quot;, headers));&#10;                        } else {&#10;                            // Validate that current file has the same headers&#10;                            List&lt;String&gt; currentHeaders = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            if (!headers.equals(currentHeaders)) {&#10;                                System.out.println(&quot;Warning: File &quot; + csvFile.getFileName() +&#10;                                    &quot; has different headers. Expected: &quot; + headers +&#10;                                    &quot;, Found: &quot; + currentHeaders);&#10;                                // Continue processing but log the warning&#10;                            }&#10;                        }&#10;&#10;                        // Copy records from current file with email processing and deduplication&#10;                        int fileRecords = 0;&#10;                        int fileSkipped = 0;&#10;                        int fileDuplicates = 0;&#10;                        for (CSVRecord record : csvParser) {&#10;                            List&lt;String&gt; recordValues = new ArrayList&lt;&gt;();&#10;&#10;                            // Check email and personal_email values&#10;                            String emailValue = &quot;&quot;;&#10;                            String personalEmailValue = &quot;&quot;;&#10;&#10;                            try {&#10;                                emailValue = record.get(&quot;email&quot;);&#10;                                if (emailValue == null) emailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                emailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            try {&#10;                                personalEmailValue = record.get(&quot;personal_email&quot;);&#10;                                if (personalEmailValue == null) personalEmailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                personalEmailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            // Skip if both email and personal_email are empty&#10;                            if (emailValue.trim().isEmpty() &amp;&amp; personalEmailValue.trim().isEmpty()) {&#10;                                fileSkipped++;&#10;                                skippedRecords++;&#10;                                continue;&#10;                            }&#10;&#10;                            // Use personal_email if email is empty but personal_email is not&#10;                            String finalEmailValue = emailValue.trim().isEmpty() ? personalEmailValue : emailValue;&#10;&#10;                            // Check for duplicate email and skip if already processed&#10;                            String normalizedEmail = finalEmailValue.trim().toLowerCase();&#10;                            if (uniqueEmails.contains(normalizedEmail)) {&#10;                                fileDuplicates++;&#10;                                duplicateRecords++;&#10;                                continue;&#10;                            }&#10;&#10;                            // Add email to unique set&#10;                            uniqueEmails.add(normalizedEmail);&#10;&#10;                            // Extract values for each header column&#10;                            for (int i = 0; i &lt; headers.size(); i++) {&#10;                                String header = headers.get(i);&#10;                                String value = &quot;&quot;;&#10;&#10;                                if (header.equalsIgnoreCase(&quot;email&quot;)) {&#10;                                    // Use the processed email value&#10;                                    value = finalEmailValue;&#10;                                } else {&#10;                                    try {&#10;                                        value = record.get(header);&#10;                                        if (value == null) {&#10;                                            value = &quot;&quot;;&#10;                                        }&#10;                                    } catch (IllegalArgumentException e) {&#10;                                        // Column doesn't exist in this file, use empty string&#10;                                        value = &quot;&quot;;&#10;                                    }&#10;                                }&#10;                                recordValues.add(value);&#10;                            }&#10;&#10;                            csvPrinter.printRecord(recordValues);&#10;                            fileRecords++;&#10;                            totalRecords++;&#10;                        }&#10;&#10;                        System.out.println(&quot;  - Records from &quot; + csvFile.getFileName() + &quot;: &quot; + fileRecords);&#10;                        if (fileSkipped &gt; 0) {&#10;                            System.out.println(&quot;  - Skipped records (no email): &quot; + fileSkipped);&#10;                        }&#10;                        if (fileDuplicates &gt; 0) {&#10;                            System.out.println(&quot;  - Duplicate emails skipped: &quot; + fileDuplicates);&#10;                        }&#10;                        processedFiles++;&#10;&#10;                    } catch (IOException e) {&#10;                        System.err.println(&quot;Error reading file &quot; + csvFile.getFileName() + &quot;: &quot; + e.getMessage());&#10;                        // Continue with other files&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (csvPrinter != null) {&#10;                csvPrinter.flush();&#10;            }&#10;&#10;            System.out.println(&quot;\n=== Summary ===&quot;);&#10;            System.out.println(&quot;Files processed: &quot; + processedFiles);&#10;            System.out.println(&quot;Total records combined: &quot; + totalRecords);&#10;            System.out.println(&quot;Total records skipped (no email): &quot; + skippedRecords);&#10;            System.out.println(&quot;Total duplicate emails skipped: &quot; + duplicateRecords);&#10;            System.out.println(&quot;Unique emails in output: &quot; + uniqueEmails.size());&#10;            System.out.println(&quot;Output file: &quot; + outputFile);&#10;&#10;            if (processedFiles == 0) {&#10;                System.out.println(&quot;No CSV files found in the prospects folder!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Alternative main method if you want to run this class directly&#10;    public static void main(String[] args) {&#10;        main2(args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>