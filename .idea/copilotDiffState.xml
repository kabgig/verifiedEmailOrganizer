<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Main.java" />
              <option name="originalContent" value="package org.example;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVPrinter;&#10;import org.apache.commons.csv.CSVRecord;&#10;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.io.Writer;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        // Get the user's desktop path&#10;        String desktopPath = System.getProperty(&quot;user.home&quot;) + &quot;/Desktop&quot;;&#10;        String checkedFile = desktopPath + &quot;/checked.csv&quot;;&#10;        String scrapedFile = desktopPath + &quot;/scraped.csv&quot;;&#10;        String outputFile = desktopPath + &quot;/filtered_scraped.csv&quot;;&#10;&#10;        // Columns to remove from scraped CSV (based on actual column names)&#10;        Set&lt;String&gt; columnsToRemove = Set.of(&#10;            &quot;Followers&quot;, &quot;Following&quot;, &quot;Tweets&quot;,&#10;            &quot;Profile picture link&quot;, &quot;Screen name&quot;, &quot;Bio&quot;&#10;        );&#10;&#10;        try {&#10;            // Step 1: Read checked emails&#10;            Set&lt;String&gt; checkedEmails = readCheckedEmails(checkedFile);&#10;            System.out.println(&quot;Loaded &quot; + checkedEmails.size() + &quot; checked emails&quot;);&#10;&#10;            // Step 2: Process scraped file&#10;            filterScrapedFile(scrapedFile, outputFile, checkedEmails, columnsToRemove);&#10;&#10;            System.out.println(&quot;Processing completed! Filtered file saved as: &quot; + outputFile);&#10;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error processing files: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static Set&lt;String&gt; readCheckedEmails(String filePath) throws IOException {&#10;        Set&lt;String&gt; emails = new HashSet&lt;&gt;();&#10;&#10;        try (Reader reader = Files.newBufferedReader(Paths.get(filePath));&#10;             CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                     .withFirstRecordAsHeader()&#10;                     .withIgnoreEmptyLines(true)&#10;                     .withTrim(true)&#10;                     .withAllowMissingColumnNames(true))) {&#10;&#10;            for (CSVRecord record : csvParser) {&#10;                // Read email from second column (index 1)&#10;                if (record.size() &gt; 1) {&#10;                    String email = record.get(1);&#10;                    if (email != null &amp;&amp; !email.trim().isEmpty() &amp;&amp;&#10;                        !email.trim().equalsIgnoreCase(&quot;ok&quot;) &amp;&amp;&#10;                        !email.trim().equalsIgnoreCase(&quot;ELV Result&quot;)) {&#10;                        emails.add(email.trim().toLowerCase());&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return emails;&#10;    }&#10;&#10;    private static void filterScrapedFile(String inputFile, String outputFile,&#10;                                        Set&lt;String&gt; checkedEmails, Set&lt;String&gt; columnsToRemove) throws IOException {&#10;&#10;        try (Reader reader = Files.newBufferedReader(Paths.get(inputFile));&#10;             CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                     .withFirstRecordAsHeader()&#10;                     .withIgnoreEmptyLines(true)&#10;                     .withTrim(true)&#10;                     .withAllowMissingColumnNames(true));&#10;             Writer writer = Files.newBufferedWriter(Paths.get(outputFile))) {&#10;&#10;            // Get headers and filter out unwanted columns&#10;            List&lt;String&gt; originalHeaders = csvParser.getHeaderNames();&#10;            List&lt;String&gt; filteredHeaders = new ArrayList&lt;&gt;();&#10;&#10;            for (String header : originalHeaders) {&#10;                if (header != null &amp;&amp; !header.trim().isEmpty() &amp;&amp; !columnsToRemove.contains(header)) {&#10;                    filteredHeaders.add(header);&#10;                }&#10;            }&#10;&#10;            // Find email column index for filtered headers&#10;            String emailColumn = findEmailColumn(originalHeaders);&#10;&#10;            // Create CSV printer with filtered headers&#10;            CSVPrinter csvPrinter = new CSVPrinter(writer,&#10;                CSVFormat.DEFAULT.withHeader(filteredHeaders.toArray(new String[0])));&#10;&#10;            int totalRows = 0;&#10;            int filteredRows = 0;&#10;&#10;            // Read scraped file line by line&#10;            for (CSVRecord record : csvParser) {&#10;                totalRows++;&#10;&#10;                // Get email from current line&#10;                String email = record.get(emailColumn);&#10;&#10;                // Check if email is present and not empty&#10;                if (email != null &amp;&amp; !email.trim().isEmpty()) {&#10;                    String normalizedEmail = email.trim().toLowerCase();&#10;&#10;                    // Only save line if email is present in checked file&#10;                    if (checkedEmails.contains(normalizedEmail)) {&#10;                        // Create filtered record (omit unwanted columns)&#10;                        List&lt;String&gt; filteredRecord = new ArrayList&lt;&gt;();&#10;                        for (String header : filteredHeaders) {&#10;                            String value = record.get(header);&#10;                            filteredRecord.add(value != null ? value : &quot;&quot;);&#10;                        }&#10;&#10;                        // Save the line to result CSV&#10;                        csvPrinter.printRecord(filteredRecord);&#10;                        filteredRows++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            csvPrinter.flush();&#10;&#10;            System.out.println(&quot;Total rows processed: &quot; + totalRows);&#10;            System.out.println(&quot;Rows with verified emails saved: &quot; + filteredRows);&#10;            System.out.println(&quot;Removed columns: &quot; + String.join(&quot;, &quot;, columnsToRemove));&#10;        }&#10;    }&#10;&#10;    private static String findEmailColumn(List&lt;String&gt; headers) {&#10;        // Try to find email column by common names&#10;        String[] emailColumnNames = {&quot;email&quot;, &quot;Email&quot;, &quot;EMAIL&quot;, &quot;e-mail&quot;, &quot;E-mail&quot;, &quot;mail&quot;, &quot;Mail&quot;};&#10;&#10;        for (String possibleName : emailColumnNames) {&#10;            if (headers.contains(possibleName)) {&#10;                return possibleName;&#10;            }&#10;        }&#10;&#10;        // If no standard email column found, look for columns containing &quot;email&quot;&#10;        for (String header : headers) {&#10;            if (header.toLowerCase().contains(&quot;email&quot;)) {&#10;                return header;&#10;            }&#10;        }&#10;&#10;        throw new RuntimeException(&quot;Could not find emails column in CSV. Available columns: &quot; +&#10;                                 String.join(&quot;, &quot;, headers));&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVPrinter;&#10;import org.apache.commons.csv.CSVRecord;&#10;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.io.Writer;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;&#10;/**&#10; * Main class for filtering scraped CSV data based on verified email addresses.&#10; * &#10; * This application processes two CSV files from the user's desktop:&#10; * 1. 'checked.csv' - Contains verified email addresses (emails from second column)&#10; * 2. 'scraped.csv' - Contains scraped data with email information&#10; * &#10; * The program filters the scraped data to only include records where the email&#10; * address is present in the checked file, and removes specified unwanted columns&#10; * (Followers, Following, Tweets, Profile picture link, Screen name, Bio).&#10; * &#10; * Output: 'filtered_scraped.csv' containing only verified email records with cleaned columns.&#10; */&#10;public class Main {&#10;    &#10;    /**&#10;     * Main entry point that orchestrates the email verification and filtering process.&#10;     * Reads verified emails from 'checked.csv', filters 'scraped.csv' based on those emails,&#10;     * removes unwanted columns, and outputs the result to 'filtered_scraped.csv'.&#10;     */&#10;    public static void main(String[] args) {&#10;        // Get the user's desktop path&#10;        String desktopPath = System.getProperty(&quot;user.home&quot;) + &quot;/Desktop&quot;;&#10;        String checkedFile = desktopPath + &quot;/checked.csv&quot;;&#10;        String scrapedFile = desktopPath + &quot;/scraped.csv&quot;;&#10;        String outputFile = desktopPath + &quot;/filtered_scraped.csv&quot;;&#10;&#10;        // Columns to remove from scraped CSV (based on actual column names)&#10;        Set&lt;String&gt; columnsToRemove = Set.of(&#10;            &quot;Followers&quot;, &quot;Following&quot;, &quot;Tweets&quot;,&#10;            &quot;Profile picture link&quot;, &quot;Screen name&quot;, &quot;Bio&quot;&#10;        );&#10;&#10;        try {&#10;            // Step 1: Read checked emails&#10;            Set&lt;String&gt; checkedEmails = readCheckedEmails(checkedFile);&#10;            System.out.println(&quot;Loaded &quot; + checkedEmails.size() + &quot; checked emails&quot;);&#10;&#10;            // Step 2: Process scraped file&#10;            filterScrapedFile(scrapedFile, outputFile, checkedEmails, columnsToRemove);&#10;&#10;            System.out.println(&quot;Processing completed! Filtered file saved as: &quot; + outputFile);&#10;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error processing files: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reads verified email addresses from the checked CSV file.&#10;     * Extracts emails from the second column (index 1) of the CSV file,&#10;     * normalizes them to lowercase, and filters out invalid entries.&#10;     * &#10;     * @param filePath Path to the checked.csv file&#10;     * @return Set of verified email addresses (normalized to lowercase)&#10;     * @throws IOException if file reading fails&#10;     */&#10;    private static Set&lt;String&gt; readCheckedEmails(String filePath) throws IOException {&#10;        Set&lt;String&gt; emails = new HashSet&lt;&gt;();&#10;&#10;        try (Reader reader = Files.newBufferedReader(Paths.get(filePath));&#10;             CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                     .withFirstRecordAsHeader()&#10;                     .withIgnoreEmptyLines(true)&#10;                     .withTrim(true)&#10;                     .withAllowMissingColumnNames(true))) {&#10;&#10;            for (CSVRecord record : csvParser) {&#10;                // Read email from second column (index 1)&#10;                if (record.size() &gt; 1) {&#10;                    String email = record.get(1);&#10;                    if (email != null &amp;&amp; !email.trim().isEmpty() &amp;&amp;&#10;                        !email.trim().equalsIgnoreCase(&quot;ok&quot;) &amp;&amp;&#10;                        !email.trim().equalsIgnoreCase(&quot;ELV Result&quot;)) {&#10;                        emails.add(email.trim().toLowerCase());&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return emails;&#10;    }&#10;&#10;    /**&#10;     * Filters the scraped CSV file based on verified emails and removes unwanted columns.&#10;     * Only includes records where the email field matches an email from the checked file.&#10;     * Removes specified columns (Followers, Following, Tweets, etc.) from the output.&#10;     * &#10;     * @param inputFile Path to the scraped.csv file&#10;     * @param outputFile Path for the filtered output file&#10;     * @param checkedEmails Set of verified email addresses&#10;     * @param columnsToRemove Set of column names to exclude from output&#10;     * @throws IOException if file processing fails&#10;     */&#10;    private static void filterScrapedFile(String inputFile, String outputFile,&#10;                                        Set&lt;String&gt; checkedEmails, Set&lt;String&gt; columnsToRemove) throws IOException {&#10;&#10;        try (Reader reader = Files.newBufferedReader(Paths.get(inputFile));&#10;             CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                     .withFirstRecordAsHeader()&#10;                     .withIgnoreEmptyLines(true)&#10;                     .withTrim(true)&#10;                     .withAllowMissingColumnNames(true));&#10;             Writer writer = Files.newBufferedWriter(Paths.get(outputFile))) {&#10;&#10;            // Get headers and filter out unwanted columns&#10;            List&lt;String&gt; originalHeaders = csvParser.getHeaderNames();&#10;            List&lt;String&gt; filteredHeaders = new ArrayList&lt;&gt;();&#10;&#10;            for (String header : originalHeaders) {&#10;                if (header != null &amp;&amp; !header.trim().isEmpty() &amp;&amp; !columnsToRemove.contains(header)) {&#10;                    filteredHeaders.add(header);&#10;                }&#10;            }&#10;&#10;            // Find email column index for filtered headers&#10;            String emailColumn = findEmailColumn(originalHeaders);&#10;&#10;            // Create CSV printer with filtered headers&#10;            CSVPrinter csvPrinter = new CSVPrinter(writer,&#10;                CSVFormat.DEFAULT.withHeader(filteredHeaders.toArray(new String[0])));&#10;&#10;            int totalRows = 0;&#10;            int filteredRows = 0;&#10;&#10;            // Read scraped file line by line&#10;            for (CSVRecord record : csvParser) {&#10;                totalRows++;&#10;&#10;                // Get email from current line&#10;                String email = record.get(emailColumn);&#10;&#10;                // Check if email is present and not empty&#10;                if (email != null &amp;&amp; !email.trim().isEmpty()) {&#10;                    String normalizedEmail = email.trim().toLowerCase();&#10;&#10;                    // Only save line if email is present in checked file&#10;                    if (checkedEmails.contains(normalizedEmail)) {&#10;                        // Create filtered record (omit unwanted columns)&#10;                        List&lt;String&gt; filteredRecord = new ArrayList&lt;&gt;();&#10;                        for (String header : filteredHeaders) {&#10;                            String value = record.get(header);&#10;                            filteredRecord.add(value != null ? value : &quot;&quot;);&#10;                        }&#10;&#10;                        // Save the line to result CSV&#10;                        csvPrinter.printRecord(filteredRecord);&#10;                        filteredRows++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            csvPrinter.flush();&#10;&#10;            System.out.println(&quot;Total rows processed: &quot; + totalRows);&#10;            System.out.println(&quot;Rows with verified emails saved: &quot; + filteredRows);&#10;            System.out.println(&quot;Removed columns: &quot; + String.join(&quot;, &quot;, columnsToRemove));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Finds the email column in the CSV headers by searching for common email column names.&#10;     * Tries variations like &quot;email&quot;, &quot;Email&quot;, &quot;EMAIL&quot;, &quot;e-mail&quot;, etc.&#10;     * &#10;     * @param headers List of CSV header names&#10;     * @return Name of the email column&#10;     * @throws RuntimeException if no email column is found&#10;     */&#10;    private static String findEmailColumn(List&lt;String&gt; headers) {&#10;        // Try to find email column by common names&#10;        String[] emailColumnNames = {&quot;email&quot;, &quot;Email&quot;, &quot;EMAIL&quot;, &quot;e-mail&quot;, &quot;E-mail&quot;, &quot;mail&quot;, &quot;Mail&quot;};&#10;&#10;        for (String possibleName : emailColumnNames) {&#10;            if (headers.contains(possibleName)) {&#10;                return possibleName;&#10;            }&#10;        }&#10;&#10;        // If no standard email column found, look for columns containing &quot;email&quot;&#10;        for (String header : headers) {&#10;            if (header.toLowerCase().contains(&quot;email&quot;)) {&#10;                return header;&#10;            }&#10;        }&#10;&#10;        throw new RuntimeException(&quot;Could not find emails column in CSV. Available columns: &quot; +&#10;                                 String.join(&quot;, &quot;, headers));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Main2.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Main2.java" />
              <option name="originalContent" value="package org.example;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVPrinter;&#10;import org.apache.commons.csv.CSVRecord;&#10;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.io.Writer;&#10;import java.nio.file.DirectoryStream;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;&#10;public class Main2 {&#10;&#10;    public static void main2(String[] args) {&#10;        // Get the user's desktop path&#10;        String desktopPath = System.getProperty(&quot;user.home&quot;) + &quot;/Desktop&quot;;&#10;        String prospectsFolder = desktopPath + &quot;/prospects&quot;;&#10;        String outputFile = desktopPath + &quot;/combined_prospects.csv&quot;;&#10;&#10;        try {&#10;            combineProspectsCsvFiles(prospectsFolder, outputFile);&#10;            System.out.println(&quot;Successfully combined all prospect CSV files into: &quot; + outputFile);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error processing prospect files: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static void combineProspectsCsvFiles(String prospectsFolder, String outputFile) throws IOException {&#10;        Path prospectsPath = Paths.get(prospectsFolder);&#10;&#10;        if (!Files.exists(prospectsPath) || !Files.isDirectory(prospectsPath)) {&#10;            throw new IOException(&quot;Prospects folder does not exist: &quot; + prospectsFolder);&#10;        }&#10;&#10;        List&lt;String&gt; headers = null;&#10;        boolean isFirstFile = true;&#10;        int totalRecords = 0;&#10;        int processedFiles = 0;&#10;        int skippedRecords = 0;&#10;        int duplicateRecords = 0;&#10;&#10;        // Track unique emails to avoid duplicates&#10;        Set&lt;String&gt; uniqueEmails = new HashSet&lt;&gt;();&#10;&#10;        try (Writer writer = Files.newBufferedWriter(Paths.get(outputFile))) {&#10;            CSVPrinter csvPrinter = null;&#10;&#10;            // Read all CSV files from the prospects folder&#10;            try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(prospectsPath, &quot;*.csv&quot;)) {&#10;                for (Path csvFile : stream) {&#10;                    System.out.println(&quot;Processing file: &quot; + csvFile.getFileName());&#10;&#10;                    try (Reader reader = Files.newBufferedReader(csvFile);&#10;                         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                                 .withFirstRecordAsHeader()&#10;                                 .withIgnoreEmptyLines(true)&#10;                                 .withTrim(true)&#10;                                 .withAllowMissingColumnNames(true))) {&#10;&#10;                        if (isFirstFile) {&#10;                            // Get headers from the first file and create CSV printer&#10;                            headers = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            csvPrinter = new CSVPrinter(writer,&#10;                                CSVFormat.DEFAULT.withHeader(headers.toArray(new String[0])));&#10;                            isFirstFile = false;&#10;                            System.out.println(&quot;Headers found: &quot; + String.join(&quot;, &quot;, headers));&#10;                        } else {&#10;                            // Validate that current file has the same headers&#10;                            List&lt;String&gt; currentHeaders = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            if (!headers.equals(currentHeaders)) {&#10;                                System.out.println(&quot;Warning: File &quot; + csvFile.getFileName() +&#10;                                    &quot; has different headers. Expected: &quot; + headers +&#10;                                    &quot;, Found: &quot; + currentHeaders);&#10;                                // Continue processing but log the warning&#10;                            }&#10;                        }&#10;&#10;                        // Copy records from current file with email processing and deduplication&#10;                        int fileRecords = 0;&#10;                        int fileSkipped = 0;&#10;                        int fileDuplicates = 0;&#10;                        for (CSVRecord record : csvParser) {&#10;                            List&lt;String&gt; recordValues = new ArrayList&lt;&gt;();&#10;&#10;                            // Check email and personal_email values&#10;                            String emailValue = &quot;&quot;;&#10;                            String personalEmailValue = &quot;&quot;;&#10;&#10;                            try {&#10;                                emailValue = record.get(&quot;email&quot;);&#10;                                if (emailValue == null) emailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                emailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            try {&#10;                                personalEmailValue = record.get(&quot;personal_email&quot;);&#10;                                if (personalEmailValue == null) personalEmailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                personalEmailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            // Skip if both email and personal_email are empty&#10;                            if (emailValue.trim().isEmpty() &amp;&amp; personalEmailValue.trim().isEmpty()) {&#10;                                fileSkipped++;&#10;                                skippedRecords++;&#10;                                continue;&#10;                            }&#10;&#10;                            // Use personal_email if email is empty but personal_email is not&#10;                            String finalEmailValue = emailValue.trim().isEmpty() ? personalEmailValue : emailValue;&#10;&#10;                            // Check for duplicate email and skip if already processed&#10;                            String normalizedEmail = finalEmailValue.trim().toLowerCase();&#10;                            if (uniqueEmails.contains(normalizedEmail)) {&#10;                                fileDuplicates++;&#10;                                duplicateRecords++;&#10;                                continue;&#10;                            }&#10;&#10;                            // Add email to unique set&#10;                            uniqueEmails.add(normalizedEmail);&#10;&#10;                            // Extract values for each header column&#10;                            for (int i = 0; i &lt; headers.size(); i++) {&#10;                                String header = headers.get(i);&#10;                                String value = &quot;&quot;;&#10;&#10;                                if (header.equalsIgnoreCase(&quot;email&quot;)) {&#10;                                    // Use the processed email value&#10;                                    value = finalEmailValue;&#10;                                } else {&#10;                                    try {&#10;                                        value = record.get(header);&#10;                                        if (value == null) {&#10;                                            value = &quot;&quot;;&#10;                                        }&#10;                                    } catch (IllegalArgumentException e) {&#10;                                        // Column doesn't exist in this file, use empty string&#10;                                        value = &quot;&quot;;&#10;                                    }&#10;                                }&#10;                                recordValues.add(value);&#10;                            }&#10;&#10;                            csvPrinter.printRecord(recordValues);&#10;                            fileRecords++;&#10;                            totalRecords++;&#10;                        }&#10;&#10;                        System.out.println(&quot;  - Records from &quot; + csvFile.getFileName() + &quot;: &quot; + fileRecords);&#10;                        if (fileSkipped &gt; 0) {&#10;                            System.out.println(&quot;  - Skipped records (no email): &quot; + fileSkipped);&#10;                        }&#10;                        if (fileDuplicates &gt; 0) {&#10;                            System.out.println(&quot;  - Duplicate emails skipped: &quot; + fileDuplicates);&#10;                        }&#10;                        processedFiles++;&#10;&#10;                    } catch (IOException e) {&#10;                        System.err.println(&quot;Error reading file &quot; + csvFile.getFileName() + &quot;: &quot; + e.getMessage());&#10;                        // Continue with other files&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (csvPrinter != null) {&#10;                csvPrinter.flush();&#10;            }&#10;&#10;            System.out.println(&quot;\n=== Summary ===&quot;);&#10;            System.out.println(&quot;Files processed: &quot; + processedFiles);&#10;            System.out.println(&quot;Total records combined: &quot; + totalRecords);&#10;            System.out.println(&quot;Total records skipped (no email): &quot; + skippedRecords);&#10;            System.out.println(&quot;Total duplicate emails skipped: &quot; + duplicateRecords);&#10;            System.out.println(&quot;Unique emails in output: &quot; + uniqueEmails.size());&#10;            System.out.println(&quot;Output file: &quot; + outputFile);&#10;&#10;            if (processedFiles == 0) {&#10;                System.out.println(&quot;No CSV files found in the prospects folder!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Alternative main method if you want to run this class directly&#10;    public static void main(String[] args) {&#10;        main2(args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVPrinter;&#10;import org.apache.commons.csv.CSVRecord;&#10;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.io.Writer;&#10;import java.nio.file.DirectoryStream;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;&#10;/**&#10; * Main2 class for combining and processing multiple prospect CSV files with email deduplication.&#10; * &#10; * This application processes all CSV files from the 'prospects' folder on the user's desktop:&#10; * - Combines all records from multiple CSV files into one unified output&#10; * - Implements intelligent email handling: uses 'personal_email' as fallback if 'email' is empty&#10; * - Ensures email uniqueness by removing duplicate email addresses (case-insensitive)&#10; * - Skips records that have no email address in either 'email' or 'personal_email' columns&#10; * - Maintains the same column structure across all input files&#10; * &#10; * Output: 'combined_prospects.csv' containing all unique prospect records with valid emails.&#10; */&#10;public class Main2 {&#10;&#10;    /**&#10;     * Main entry point for combining prospect CSV files with email processing and deduplication.&#10;     * Processes all CSV files in the prospects folder and creates a unified, deduplicated output.&#10;     */&#10;    public static void main2(String[] args) {&#10;        // Get the user's desktop path&#10;        String desktopPath = System.getProperty(&quot;user.home&quot;) + &quot;/Desktop&quot;;&#10;        String prospectsFolder = desktopPath + &quot;/prospects&quot;;&#10;        String outputFile = desktopPath + &quot;/combined_prospects.csv&quot;;&#10;&#10;        try {&#10;            combineProspectsCsvFiles(prospectsFolder, outputFile);&#10;            System.out.println(&quot;Successfully combined all prospect CSV files into: &quot; + outputFile);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error processing prospect files: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Combines all CSV files from the prospects folder into a single output file with email processing.&#10;     * &#10;     * Features:&#10;     * - Reads all .csv files from the specified folder&#10;     * - Uses first file's headers as the master column structure&#10;     * - Processes email fields with intelligent fallback (email -&gt; personal_email)&#10;     * - Removes duplicate email addresses (case-insensitive comparison)&#10;     * - Skips records with no valid email address&#10;     * - Provides detailed processing statistics&#10;     * &#10;     * @param prospectsFolder Path to the folder containing prospect CSV files&#10;     * @param outputFile Path for the combined output CSV file&#10;     * @throws IOException if file processing fails&#10;     */&#10;    private static void combineProspectsCsvFiles(String prospectsFolder, String outputFile) throws IOException {&#10;        Path prospectsPath = Paths.get(prospectsFolder);&#10;&#10;        if (!Files.exists(prospectsPath) || !Files.isDirectory(prospectsPath)) {&#10;            throw new IOException(&quot;Prospects folder does not exist: &quot; + prospectsFolder);&#10;        }&#10;&#10;        List&lt;String&gt; headers = null;&#10;        boolean isFirstFile = true;&#10;        int totalRecords = 0;&#10;        int processedFiles = 0;&#10;        int skippedRecords = 0;&#10;        int duplicateRecords = 0;&#10;&#10;        // Track unique emails to avoid duplicates&#10;        Set&lt;String&gt; uniqueEmails = new HashSet&lt;&gt;();&#10;&#10;        try (Writer writer = Files.newBufferedWriter(Paths.get(outputFile))) {&#10;            CSVPrinter csvPrinter = null;&#10;&#10;            // Read all CSV files from the prospects folder&#10;            try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(prospectsPath, &quot;*.csv&quot;)) {&#10;                for (Path csvFile : stream) {&#10;                    System.out.println(&quot;Processing file: &quot; + csvFile.getFileName());&#10;&#10;                    try (Reader reader = Files.newBufferedReader(csvFile);&#10;                         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT&#10;                                 .withFirstRecordAsHeader()&#10;                                 .withIgnoreEmptyLines(true)&#10;                                 .withTrim(true)&#10;                                 .withAllowMissingColumnNames(true))) {&#10;&#10;                        if (isFirstFile) {&#10;                            // Get headers from the first file and create CSV printer&#10;                            headers = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            csvPrinter = new CSVPrinter(writer,&#10;                                CSVFormat.DEFAULT.withHeader(headers.toArray(new String[0])));&#10;                            isFirstFile = false;&#10;                            System.out.println(&quot;Headers found: &quot; + String.join(&quot;, &quot;, headers));&#10;                        } else {&#10;                            // Validate that current file has the same headers&#10;                            List&lt;String&gt; currentHeaders = new ArrayList&lt;&gt;(csvParser.getHeaderNames());&#10;                            if (!headers.equals(currentHeaders)) {&#10;                                System.out.println(&quot;Warning: File &quot; + csvFile.getFileName() +&#10;                                    &quot; has different headers. Expected: &quot; + headers +&#10;                                    &quot;, Found: &quot; + currentHeaders);&#10;                                // Continue processing but log the warning&#10;                            }&#10;                        }&#10;&#10;                        // Copy records from current file with email processing and deduplication&#10;                        int fileRecords = 0;&#10;                        int fileSkipped = 0;&#10;                        int fileDuplicates = 0;&#10;                        for (CSVRecord record : csvParser) {&#10;                            List&lt;String&gt; recordValues = new ArrayList&lt;&gt;();&#10;&#10;                            // Check email and personal_email values&#10;                            String emailValue = &quot;&quot;;&#10;                            String personalEmailValue = &quot;&quot;;&#10;&#10;                            try {&#10;                                emailValue = record.get(&quot;email&quot;);&#10;                                if (emailValue == null) emailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                emailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            try {&#10;                                personalEmailValue = record.get(&quot;personal_email&quot;);&#10;                                if (personalEmailValue == null) personalEmailValue = &quot;&quot;;&#10;                            } catch (IllegalArgumentException e) {&#10;                                personalEmailValue = &quot;&quot;;&#10;                            }&#10;&#10;                            // Skip if both email and personal_email are empty&#10;                            if (emailValue.trim().isEmpty() &amp;&amp; personalEmailValue.trim().isEmpty()) {&#10;                                fileSkipped++;&#10;                                skippedRecords++;&#10;                                continue;&#10;                            }&#10;&#10;                            // Use personal_email if email is empty but personal_email is not&#10;                            String finalEmailValue = emailValue.trim().isEmpty() ? personalEmailValue : emailValue;&#10;&#10;                            // Check for duplicate email and skip if already processed&#10;                            String normalizedEmail = finalEmailValue.trim().toLowerCase();&#10;                            if (uniqueEmails.contains(normalizedEmail)) {&#10;                                fileDuplicates++;&#10;                                duplicateRecords++;&#10;                                continue;&#10;                            }&#10;&#10;                            // Add email to unique set&#10;                            uniqueEmails.add(normalizedEmail);&#10;&#10;                            // Extract values for each header column&#10;                            for (int i = 0; i &lt; headers.size(); i++) {&#10;                                String header = headers.get(i);&#10;                                String value = &quot;&quot;;&#10;&#10;                                if (header.equalsIgnoreCase(&quot;email&quot;)) {&#10;                                    // Use the processed email value&#10;                                    value = finalEmailValue;&#10;                                } else {&#10;                                    try {&#10;                                        value = record.get(header);&#10;                                        if (value == null) {&#10;                                            value = &quot;&quot;;&#10;                                        }&#10;                                    } catch (IllegalArgumentException e) {&#10;                                        // Column doesn't exist in this file, use empty string&#10;                                        value = &quot;&quot;;&#10;                                    }&#10;                                }&#10;                                recordValues.add(value);&#10;                            }&#10;&#10;                            csvPrinter.printRecord(recordValues);&#10;                            fileRecords++;&#10;                            totalRecords++;&#10;                        }&#10;&#10;                        System.out.println(&quot;  - Records from &quot; + csvFile.getFileName() + &quot;: &quot; + fileRecords);&#10;                        if (fileSkipped &gt; 0) {&#10;                            System.out.println(&quot;  - Skipped records (no email): &quot; + fileSkipped);&#10;                        }&#10;                        if (fileDuplicates &gt; 0) {&#10;                            System.out.println(&quot;  - Duplicate emails skipped: &quot; + fileDuplicates);&#10;                        }&#10;                        processedFiles++;&#10;&#10;                    } catch (IOException e) {&#10;                        System.err.println(&quot;Error reading file &quot; + csvFile.getFileName() + &quot;: &quot; + e.getMessage());&#10;                        // Continue with other files&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (csvPrinter != null) {&#10;                csvPrinter.flush();&#10;            }&#10;&#10;            System.out.println(&quot;\n=== Summary ===&quot;);&#10;            System.out.println(&quot;Files processed: &quot; + processedFiles);&#10;            System.out.println(&quot;Total records combined: &quot; + totalRecords);&#10;            System.out.println(&quot;Total records skipped (no email): &quot; + skippedRecords);&#10;            System.out.println(&quot;Total duplicate emails skipped: &quot; + duplicateRecords);&#10;            System.out.println(&quot;Unique emails in output: &quot; + uniqueEmails.size());&#10;            System.out.println(&quot;Output file: &quot; + outputFile);&#10;&#10;            if (processedFiles == 0) {&#10;                System.out.println(&quot;No CSV files found in the prospects folder!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Alternative main method for running this class directly.&#10;     * Simply delegates to the main2 method for backward compatibility.&#10;     */&#10;    public static void main(String[] args) {&#10;        main2(args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>